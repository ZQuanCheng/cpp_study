# cpp_data_structure 

* 代码随想录 https://programmercarl.com/

* 一个有非常简明例子的cpp网站：https://en.cppreference.com/w/

--------------------------------------------------------------------------------
> **大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。**
> 
> 做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，
> 
> 一样的代码多提交几次可能就击败百分之百了....
--------------------------------------------------------------------------------

# 字符串

--------------------------------------------------------------------------------

## 字符串总结

## String_Summary.md

--------------------------------------------------------------------------------



### 什么是字符串

> 
> 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说`C/C++`中的字符串。
>
> 在`C`语言中，把一个字符串存入一个数组时，也把结束符 `'\0'`存入数组，并以此作为该字符串是否结束的标志。
>
> 例如这段代码：
>
> ```c++
> char a[5] = "asd";
> for (int i = 0; a[i] != '\0'; i++) {
> }
> ``` 
> 
> 在`C++`中，提供一个`string`类，`string`类会提供 `size` 接口，可以用来判断`string`类字符串是否结束，就不用`'\0'`来判断是否结束。
>
> 例如这段代码:
>
> ```c++
> string a = "asd";
> for (int i = 0; i < a.size(); i++) {
> }
> ``` 
> 
> 那么`vector<char>` 和 `string` 又有什么区别呢？
>
> 其实在基本操作上没有区别，但是 `string` 提供更多的字符串处理的相关接口，例如 `string` 重载了`+`，而`vector`却没有。
>
> 所以想处理字符串，我们还是会定义一个`string`类型。
>
> 以下是`C风格字符数组`转换为`string`的方式
>
> ```c++
> const char *cp = "hello world";//最后有一个空字符
> char cp2[] = "hello world";//最后有一个空字符
> char cp3[] = { 'h', 'e' };//最后没有空字符
> 
> (1) string s1(cp);//s1为”hello world”，长度为11
> (2) string s2(cp2);//s2为”hello world”，长度为11
> (3) string s3(cp3);//因为cp3不以空字符结尾，所以这是未定义行为
>  
> (4) string s4(cp,5);//s4为”hello”，长度为5。将cp改为cp2一样
> (5) string s5(cp,13);//s5为”hello world  ”，长度为13,后面有两个空字符。将cp改为cp2一样
> (6) string s6(cp3,2);//s6为”he”，长度为2
> 
> 
> string s1("value");
> 
> (1) string s2(s1, 1);//s2为” alue”,长度为4
> (2) string s3(s1, 5);//s3为””,长度为0
> (3) string s8(s1, 6);// 错误，未定义的行为，抛出异常
> 
> (4) string s4(s1, 1,3);// s4为” alu”,长度为3
> (5) string s5(s1, 1,8);// 正确，s5为” alue”,长度为4
> (6) string s6(s1, 5,8);// s6为””,长度为0
> (7) string s7(s1, 6,1);// 错误，未定义的行为，抛出异常
> 
> 
> 
> string s ("value");
> 
> (1)string s2 = s.substr();//s2为”value”,大小为5
> 
> (2)string s3 = s.substr(2);//s3为”lue”,大小为3
> (3)string s4 = s.substr(5);//s3为””,大小为0
> (4)string s5 = s.substr(6);//错误，s5的大小为pos = 5，小于s.size()
> 
> (5)string s6 = s.substr(1,2);// s6为”al”,大小为2
> (6)string s7 = s.substr(1,7);// s7为”alue”,大小为4
> (7)string s8 = s.substr(5,7);// s8为””,大小为0
> (8)string s9 = s.substr(6,7);// 错误，s9的大小为pos = 5，小于s.size()
> ```
> 
> 



### 要不要使用库函数

>
> 在文章344.反转字符串 (`_1_reverse_string.md`)中强调了打基础的时候，不要太迷恋于库函数。
>
> 甚至一些同学习惯于调用`substr`，`split`，`reverse`之类的库函数，却不知道其实现原理，也不知道其时间复杂度，这样实现出来的代码，如果在面试现场，面试官问：“分析其时间复杂度”的话，一定会一脸懵逼！
>
> 所以建议**如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数**。
> 
> **如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数**。
>
> 
> 


#### 双指针法

> `_1_reverse_string.md` 344.反转字符串
> 
> 在344.反转字符串 (`_1_reverse_string.md`)，我们使用双指针法实现了反转字符串的操作，**双指针法在数组，链表和字符串中很常用**。
>

>
> `_3_ti_huan_kong_ge_lcof.md` 剑指 Offer 05. 替换空格
> 
> 接着在字符串：替换空格 (`_3_ti_huan_kong_ge_lcof.md`)，同样还是使用双指针法在时间复杂度`O(n)`的情况下完成替换空格。
>
> **其实很多数组填充类的问题，都可以先预先给数组扩容为填充后的大小，然后在从后向前进行操作**。
>
> 那么针对数组删除操作的问题，其实在27. 移除元素 (`../_2_1_Array/_2_remove_element.md`)中就已经提到了使用双指针法进行移除操作。
>

> 
> `_4_reverse_words_in_a_string.md` 151.翻转字符串里的单词
> 
> 同样的道理在151.翻转字符串里的单词 (`_4_reverse_words_in_a_string.md`)中我们使用`O(n)`的时间复杂度，完成了删除冗余空格。
>
> 一些同学会使用`for`循环里调用库函数`erase`来移除元素，这其实是`O(n^2)`的操作，因为`erase`就是`O(n)`的操作，所以这也是典型的不知道库函数的时间复杂度，上来就用的案例了。 
>
> 


#### 反转系列

> 
> 在反转上还可以在加一些玩法，其实考察的是对代码的掌控能力
>


> `_2_reverse_string_ii.md`  541. 反转字符串II
> 
> 541.反转字符串II (`_2_reverse_string_ii.md`)中，一些同学可能为了处理逻辑：每隔`2k`个字符的前`k`的字符，写了一堆逻辑代码或者再搞一个计数器，来统计`2k`，再统计前`k`个字符。
>
> 其实**当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章**。
>
> 只要让 `i += (2 * k)`，`i` 每次移动 `2 * k` 就可以了，然后判断是否需要有反转的区间。
>
> 因为要找的也就是每 `2 * k` 区间的起点，这样写程序会高效很多。
>


> `_4_reverse_words_in_a_string.md` 151.翻转字符串里的单词
> 
> 在151.翻转字符串里的单词 (`_4_reverse_words_in_a_string.md`)中要求翻转字符串里的单词，这道题目可以说是综合考察了字符串的多种操作。是考察字符串的好题。
>
> 这道题目通过 **先整体反转再局部反转**，实现了反转字符串里的单词。
>
> 后来发现反转字符串还有一个牛逼的用处，就是达到左旋的效果。
>


> `_5_zuo_xuan_zhuan_zi_fu_chuan_lcof.md` 剑指Offer58-II.左旋转字符串
> 
> 在字符串：反转个字符串还有这个用处？ (`_5_zuo_xuan_zhuan_zi_fu_chuan_lcof.md`)中，我们通过**先局部反转再整体反转**达到了左旋的效果。
>
> 


#### KMP

>
> `KMP`的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了**。
>
> KMP的精髓所在就是前缀表，在KMP精讲 (`KMP.md`)中提到了，什么是`KMP`，什么是前缀表，以及为什么要用前缀表。
>
> 前缀表：起始位置到下标`i`之前（包括`i`）的子串中，有多大长度的相同前缀后缀。
>
> 那么使用`KMP`可以解决两类经典问题：
>
> 1. 匹配问题：28. 实现 strStr()(`_6_find_the_index_of_the_first_occurrence_in_a_string.md`)
> 
> 2. 重复子串问题：459.重复的子字符串(`_7_repeated_substring_pattern.md`)
>
> 再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。
>
> 前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。
> 
> 后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。
> 
> 然后针对前缀表到底要不要减一，这其实是不同`KMP`实现的方式，我们在`KMP`精讲 (`KMP.md`)中针对之前两个问题，分别给出了两个不同版本的的`KMP`实现。
>
> 其中主要理解`j=next[x]`这一步最为关键！
>
> 
> 


#### 总结

>
> 字符串类类型的题目，往往想法比较简单，但是实现起来并不容易，复杂的字符串题目非常考验对代码的掌控能力。
>
> 双指针法是字符串处理的常客。
>
> `KMP`算法是字符串查找最重要的算法，但彻底理解`KMP`并不容易，我们已经写了五篇`KMP`的文章，不断总结和完善，最终才把`KMP`讲清楚。
>
> 好了字符串相关的算法知识就介绍到了这里了，明天开始新的征程，大家加油！
>
> 









