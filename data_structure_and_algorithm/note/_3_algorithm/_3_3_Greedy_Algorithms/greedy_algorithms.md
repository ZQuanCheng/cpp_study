# cpp_algorithms

* 代码随想录 https://programmercarl.com/

* geeksforgeeks https://www.geeksforgeeks.org

--------------------------------------------------------------------------------
> **大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。**
> 
> 做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，
> 
> 一样的代码多提交几次可能就击败百分之百了....
--------------------------------------------------------------------------------

# 贪心算法

https://www.geeksforgeeks.org/greedy-algorithms/

--------------------------------------------------------------------------------

## 贪心算法和动态规划的区别

>
> <font color="gree">
> 
> 贪心算法表示每一步的决策都不会浪费，每一次求解都是当前的最优解。举个例子：我每次给你两张纸币，问你怎么选择，最后才能拿到一共最多的钱。当然我每次都选最多的，因为不管什么时候结束，我做的选择都是对的，每一步选择的都没问题，都是全局最优。
> 
> 而动态规划算法会对每个决策进行求解，放在表格里，最后选择最优解（部分文章认为包含贪心）。举个例子：在一个迷宫里每一格都是一张纸币，只能两个方向走，问你怎么走，最后到达终点才能拿到一共最多的钱。这样我的每次选择都不一定是对的，因为每一步的选择都是局部最优，并非全局最优。
> 
> </font>
> 

--------------------------------------------------------------------------------

## 贪心算法理论基础

## greedy_algorithms.md

--------------------------------------------------------------------------------

### 什么是贪心

> 
> **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。 
> 
> 这么说有点抽象，来**举一个例子**：
>
> 例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？
>
> 指定每次拿最大的，最终结果就是拿走最大数额的钱。
>
> 每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。
>
> **再举一个例子**： 
>
> 如果是有一堆盒子，你有一个背包体积为`n`，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。
> 
> 例如：有`N`件物品和一个最多能背重量为 `W` 的背包。第`i`件物品的重量是`weight[i]`，得到的价值是`value[i]` 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
>
> <font color="gree">这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解</font>。
> 

### 贪心的套路（什么时候用贪心）

> 
> 很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。
> 
> **说实话贪心算法并没有固定的套路**。
>
> 所以**<font color="gree">唯一的难点就是如何通过局部最优，推出整体最优</font>**。
>
> 那么**如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？**
>
> **不好意思，也没有！** 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。
>
> 有同学问了**如何验证可不可以用贪心算法呢？**
>
> **最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。**
>
> 可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。
>
> 一般数学证明有如下两种方法：
>
> * 数学归纳法
> * 反证法
> 
> 看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。
>
> **面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了**。
>
> 举一个不太恰当的例子：我要用一下`1+1 = 2`，但我要先证明`1+1` 为什么等于`2`。严谨是严谨了，但没必要。
>
> 虽然这个例子很极端，但可以表达这么个意思：**<font color="gree">刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</font>**。
>
> **例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！**
>
> **所以这也是为什么很多同学通过（`accept`）了贪心的题目，但都不知道自己用了贪心算法，因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！**
>
> **那么刷题的时候什么时候真的需要数学推导呢？**
> 
> 例如这道题目：[链表：环找到了，那入口呢？](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html)，这道题不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下。
>
> 

### 贪心一般解题步骤

> <font color="gree">
> 
> 贪心算法一般分为如下四步：
>
> * 将问题分解为若干个子问题
> * 找出适合的贪心策略
> * 求解每一个子问题的最优解
> * 将局部最优解堆叠成全局最优解
>
> 这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。
>
> </font>
> 
>
> **做题的时候，只要想清楚 局部最优 是什么，如何推导出全局最优，其实就够了**。
>
> 
> 


### 总结

>
> 本篇给出了什么是贪心以及大家关心的贪心算法固定套路。
>
> **不好意思了，贪心没有套路，说白了就是常识性推导加上举反例。**
>
> 最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。
> 















