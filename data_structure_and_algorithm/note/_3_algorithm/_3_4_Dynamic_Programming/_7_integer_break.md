# cpp_algorithms

* 代码随想录 https://programmercarl.com/

* geeksforgeeks https://www.geeksforgeeks.org

--------------------------------------------------------------------------------
> **大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。**
> 
> 做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，
> 
> 一样的代码多提交几次可能就击败百分之百了....
--------------------------------------------------------------------------------

# 动态规划

https://www.geeksforgeeks.org/dynamic-programming/

--------------------------------------------------------------------------------

## 整数拆分

## _7_integer_break.md

--------------------------------------------------------------------------------

### 343. 整数拆分

> 
> Leetcode链接: https://leetcode.cn/problems/integer-break/
>
> 给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。
>
> 返回 `你可以获得的最大乘积` 。
> 
> 
> **示例1：**
> 
> ```html
> 输入: n = 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1。
> ```
> 
> **示例2：**
> 
> ```html
> 输入: n = 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
> ```
>
> **提示：**
> * `2 <= n <= 58`
>
> ```c++
> class Solution {
> public:
>     int integerBreak(int n) {
> 
>     }
> };
> ```
> 
> 



#### 我的思路及解法

>
> 思路如下
> 
```c++
class Solution {
public:
    int integerBreak(int n) {
        // 问题转化
        // 先从1~n-1范围内，取出k个数(2 <= k <= n)，目标和target = n
        // 这样有很多个情况，所有情况遍历，然后计算乘积，进行比较
        // 这样的话，时间复杂度很高. 比如，k=2时，有C(2,n-1)种组合，...，k = n-1时，有C(n-1,n-1)种组合;
        // 其实不止，还可以出现重复数字
        // 暴力枚举的难度很高

        // 回溯也是暴力枚举，没区别
        // 贪心我不会
        // 动规怎么弄？

        // dp[k]数组的含义是什么？将n拆分成k个正整数之和，对应的乘积？，但是每个k对应的的不止一个组合，由于那就得二维数组了,dp[][]
        // 假设n=6
        // k=6时: {1, 1, 1, 1, 1, 1}
        // k=5时: {1, 1, 1, 1, 2}
        // k=4时: {1, 1, 1, 3}, {1, 1, 2, 2} 
        // k=3时：{1, 1, 4}, {1, 2, 3}, {2, 2, 2}
        // k=2时：{1, 5}, {2, 4}, {3, 3}
        // 递归公式是什么？dp[k]和dp[k-1]的有什么联系？ 
        // 拆分成k个正整数和拆分成k-1个正整数的区别在哪里？找到这个区别，就能找到递推公式
        

        // 上面的dp[][]定义行不通，需要修改

        // dp[n]数组的含义：n拆分得到的组合中，“ 最大的 ” 乘积
        // 那么dp[n]和dp[n-1]有什么关联呢? 好像没有单独的递归关联
        // 那么dp[n]与dp[n-1]、dp[n-1]、,,,、dp[2]、dp[1]有关联吗？
        
        // 假设n=6
        // k=6时: {1, 1, 1, 1, 1, 1}
        // k=5时: {1, 1, 1, 1, 2}
        // k=4时: {1, 1, 1, 3}, {1, 1, 2, 2} 
        // k=3时：{1, 1, 4}, {1, 2, 3}, {2, 2, 2}
        // k=2时：{1, 5}, {2, 4}, {3, 3}
        
        // 假设n=5
        // k=5时: {1, 1, 1, 1, 1}
        // k=4时: {1, 1, 1, 2}
        // k=3时: {1, 1, 3}, {1, 2, 2} 
        // k=2时：{1, 4}, {2, 3}

        // 假设n=4
        // k=4时: {1, 1, 1, 1}
        // k=3时: {1, 1, 2}
        // k=2时: {1, 3}, {2, 2} 

        // 假设n=3
        // k=3时: {1, 1, 1}
        // k=2时: {1, 2}

        // 假设n=2
        // k=2时: {1, 1}

        // 我们看n=6，
        // 当拆分组合存在1时，除了{1,5}, 剩下的各种情况，都属于n=5时的拆分；那么这里面的最大值就是max{1*5, 1*dp[5]}
        // 当拆分组合存在2时，除了{2,4}, 剩下的各种情况，都属于n=4时的拆分；那么这里面的最大值就是max{2*4, 2*dp[4]}
        // 当拆分组合存在3时，除了{3,3}, 剩下的各种情况，都属于n=3时的拆分；那么这里面的最大值就是max{3*3, 3*dp[3]}
        // 当拆分组合存在4时，除了{4,2}, 剩下的各种情况，都属于n=2时的拆分；那么这里面的最大值就是max{4*2, 4*dp[2]}
        // 当拆分组合存在5时，只有{5,1}, 而且被上面的第一种情况所包含, 不考虑    
        // 则dp[6] = max{1*5, 1*dp[5], 2*4, 2*dp[4], 3*3, 3*dp[3], 4*2, 4*dp[2]}
       
        // 可以得到递推公式dp[i] = max{j*(i-j), dp[j]*(i-j)} j = 2,3,..., n-1
        
        // 初始化dp[2] = 1; 

        // 遍历方式：从i=3开始，到i=n结束

        // 返回dp[n]

    }
};
```


>
> 代码如下
> 
```c++
class Solution {
public:
    int integerBreak(int n) {
        // dp[n]数组的含义：n 拆分得到的组合中，“最大的” 乘积
        vector<int> dp(n+1, 0); // 由于要索引到dp[n]，则长度最低为n+1
        // 初始化dp[2] = 1;
        dp[2] = 1; 
        // 遍历方式：从i=3开始，到i=n结束
        for(int i=3; i <= n; i++) {
            // 递推公式dp[i] = max{j*(i-j), dp[j]*(i-j)} j = 2,3,..., n-1
            for(int j=2; j <= n-1; j++) {
                int temp = max(j * (i-j), dp[j] * (i-j));  
                if(temp > dp[i]) dp[i] = temp;
            }
        }
        // 返回dp[n]        
        return dp[n];
    }
};
```




#### 代码随想录

##### 思路

> 
> 看到这道题目，都会想拆成两个呢，还是三个呢，还是四个....
> 
> 我们来看一下如何使用动规来解决。
> 
> 

##### 动态规划

>
> 动规五部曲，分析如下：
>
> 1. 确定`dp`数组（`dp table`）以及下标的含义
>
> `dp[i]`：分拆数字`i`，可以得到的最大乘积为`dp[i]`。
> 
> `dp[i]`的定义将贯彻整个解题过程，下面哪一步想不懂了，就想想`dp[i]`究竟表示的是啥！
> 
> 2. 确定递推公式
>
> 可以想 `dp[i]`最大乘积是怎么得到的呢？
>
> 其实可以从`1`遍历`j`，然后有两种渠道得到`dp[i]`.
>
> 一个是`j * (i - j)` 直接相乘。
> 
> 一个是`j * dp[i - j]`，相当于是拆分`(i - j)`，对这个拆分不理解的话，可以回想`dp`数组的定义。
>
> **那有同学问了，`j`怎么就不拆分呢？**
>
> `j`是从`1`开始遍历，拆分`j`的情况，在遍历j的过程中其实都计算过了。那么从`1`遍历`j`，比较`(i - j) * j`和`dp[i - j] * j` 取最大的。递推公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));`
>
> 也可以这么理解，`j * (i - j)` 是单纯的把整数拆分为两个数相乘，而`j * dp[i - j]`是拆分成两个以及两个以上的个数相乘。
>
> 如果定义`dp[i - j] * dp[j]` 也是默认将一个数强制拆成`4`份以及`4`份以上了。
>
> 所以递推公式：`dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});`
>
> 那么在取最大值的时候，为什么还要比较`dp[i]`呢？
>
> 因为在递推公式推导的过程中，每次计算`dp[i]`，取最大的而已。
>
> 
> 3. `dp`的初始化
>
> 不少同学应该疑惑，`dp[0] dp[1]`应该初始化多少呢？
>
> 有的题解里会给出`dp[0] = 1，dp[1] = 1`的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。
> 
> 严格从`dp[i]`的定义来说，`dp[0] dp[1]` 就不应该初始化，也就是没有意义的数值。
>
> 拆分`0`和拆分`1`的最大乘积是多少？
>
> 这是无解的。
>
> 这里我只初始化`dp[2] = 1`，从`dp[i]`的定义来说，拆分数字`2`，得到的最大乘积是`1`，这个没有任何异议！
>
> 
> 4. 确定遍历顺序
>
> 确定遍历顺序，先来看看递归公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));`
>
> `dp[i]` 是依靠 `dp[i - j]`的状态，所以遍历`i`一定是从前向后遍历，先有`dp[i - j]`再有`dp[i]`。
>
> 所以遍历顺序为：
>
> ```c++
> for (int i = 3; i <= n ; i++) {
>     for (int j = 1; j < i - 1; j++) {
>         dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
>     }
> }
> ```
> 
> 注意 枚举`j`的时候，是从`1`开始的。从`0`开始的话，那么让拆分一个数拆个`0`，求最大乘积就没有意义了。
>
> `j`的结束条件是 `j < i - `1 ，其实 `j < i` 也是可以的，不过可以节省一步，例如让`j = i - 1`，的话，其实在 `j = 1`的时候，这一步就已经拆出来了，重复计算，所以 `j < i - 1`
>
> 至于 `i`是从`3`开始，这样`dp[i - j]`就是`dp[2]`正好可以通过我们初始化的数值求出来。
>
> 更优化一步，可以这样：
>
> ```c++
> for (int i = 3; i <= n ; i++) {
>     for (int j = 1; j <= i / 2; j++) {
>         dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
>     }
> }
> ```
> 
> 因为拆分一个数 `n` 使之乘积最大，那么一定是拆分成`m`个近似相同的子数相乘才是最大的。
>
> 例如 `6` 拆成 `3 * 3`， `10` 拆成 `3 * 3 * 4`。 `100`的话 也是拆成`m`个近似数组的子数 相乘才是最大的。
>
> 只不过我们不知道`m`究竟是多少而已，但可以明确的是`m`一定大于等于`2`，既然`m`大于等于`2`，也就是 最差也应该是拆成两个相同的 可能是最大值。
>
> 那么 `j` 遍历，只需要遍历到 `n/2` 就可以，后面就没有必要遍历了，一定不是最大值。
>
> 至于 “拆分一个数`n` 使之乘积最大，那么一定是拆分成`m个近似相同的子数相乘才是最大的” 这个我就不去做数学证明了，感兴趣的同学，可以自己证明。
>
> 
> 5. 举例推导`dp`数组
> 
> 
> 以上动规五部曲分析完毕，C++代码如下：
>
> ```c++
> class Solution {
> public:
>     int integerBreak(int n) {
>         vector<int> dp(n + 1);
>         dp[2] = 1;
>         for (int i = 3; i <= n ; i++) {
>             for (int j = 1; j <= i / 2; j++) {
>                 dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
>             }
>         }
>         return dp[n];
>     }
> };
> ```
> 
> * 时间复杂度：`O(n^2)`
> * 空间复杂度：`O(n)`
> 
> 



##### 贪心

>
> 本题也可以用贪心，每次拆成`n`个`3`，如果剩下是`4`，则保留`4`，然后相乘，但是这个结论需要数学证明其合理性！ 
>
> 我没有证明，而是直接用了结论。感兴趣的同学可以自己再去研究研究数学证明哈。
>
> 给出我的C++代码如下：
>
> ```c++
> class Solution {
> public:
>     int integerBreak(int n) {
>         if (n == 2) return 1;
>         if (n == 3) return 2;
>         if (n == 4) return 4;
>         int result = 1;
>         while (n > 4) {
>             result *= 3;
>             n -= 3;
>         }
>         result *= n;
>         return result;
>     }
> };
> ```
> 
> * 时间复杂度：`O(n)`
> * 空间复杂度：`O(1)`
> 


##### 总结

> 
> 本题掌握其动规的方法，就可以了，贪心的解法确实简单，但需要有数学证明，如果能自圆其说也是可以的。
>
> 其实这道题目的递推公式并不好想，而且初始化的地方也很有讲究，我在写本题的时候一开始写的代码是这样的：
>
> ```c++
> class Solution {
> public:
>     int integerBreak(int n) {
>         if (n <= 3) return 1 * (n - 1);
>         vector<int> dp(n + 1, 0);
>         dp[1] = 1;
>         dp[2] = 2;
>         dp[3] = 3;
>         for (int i = 4; i <= n ; i++) {
>             for (int j = 1; j <= i / 2; j++) {
>                 dp[i] = max(dp[i], dp[i - j] * dp[j]);
>             }
>         }
>         return dp[n];
>     }
> };
> ```
> 
> 这个代码也是可以过的！
>
> 在解释递推公式的时候，也可以解释通，`dp[i]` 就等于 `拆解i - j的最大乘积 * 拆解j的最大乘积`。 看起来没毛病！
>
> 但是在解释初始化的时候，就发现自相矛盾了，d`p[1]`为什么一定是`1`呢？根据`dp[i]`的定义，`dp[2]`也不应该是`2`啊。
>
> 但如果递归公式是 `dp[i] = max(dp[i], dp[i - j] * dp[j]);`，就一定要这么初始化。递推公式没毛病，但初始化解释不通！
>
> 虽然代码在初始位置有一个判断`if (n <= 3) return 1 * (n - 1);`，保证`n<=3` 结果是正确的，但代码后面又要给`dp[1]`赋值`1` 和 `dp[2]` 赋值 `2`，这其实就是自相矛盾的代码，违背了`dp[i]`的定义！
>
> 我举这个例子，其实就说做题的严谨性，上面这个代码也可以`AC`，大体上一看好像也没有毛病，递推公式也说得过去，但是仅仅是恰巧过了而已。
>
> 









