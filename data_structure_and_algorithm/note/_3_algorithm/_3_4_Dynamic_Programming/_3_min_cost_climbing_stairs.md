# cpp_algorithms

* 代码随想录 https://programmercarl.com/

* geeksforgeeks https://www.geeksforgeeks.org

--------------------------------------------------------------------------------
> **大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。**
> 
> 做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，
> 
> 一样的代码多提交几次可能就击败百分之百了....
--------------------------------------------------------------------------------

# 动态规划

https://www.geeksforgeeks.org/dynamic-programming/

--------------------------------------------------------------------------------

## 使用最小花费爬楼梯

## _3_min_cost_climbing_stairs.md

--------------------------------------------------------------------------------

### 746. 使用最小花费爬楼梯

> 
> Leetcode链接: https://leetcode.cn/problems/min-cost-climbing-stairs/
>
> 给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶
>
> 你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。
>
> 请你计算并返回达到楼梯顶部的最低花费。
>
> 
> **示例1：**
> 
> ```html
> 输入：cost = [10,15,20]
> 输出：15
> 解释：你将从下标为 1 的台阶开始。
> - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
> 总花费为 15 。
> ```
> 
> **示例2：**
> 
> ```html
> 输入：cost = [1,100,1,1,1,100,1,1,100,1]
> 输出：6
> 解释：你将从下标为 0 的台阶开始。
> - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
> - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
> - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
> 总花费为 6 。
> ```
>
> **提示：**
> * `2 <= cost.length <= 1000`
> * `0 <= cost[i] <= 999`
>
> ```c++
> class Solution {
> public:
>     int minCostClimbingStairs(vector<int>& cost) {
> 
>     }
> };
> ```
> 
> 



#### 我的思路及代码(思路在注释中体现)



> <font color="yellow">
> 
> 为什么想到要用动态规划？？？
>
> * 该问题有很多重叠子问题
> > <font color="yellow">
> > 
> > 如果只是这个原因，那么也许可以用贪心算法，局部选最优，但是还有一个原因
> > 
> > </font>
>
> * 每一个状态一定是由上一个状态推导出来的
> > <font color="yellow">
> > 
> > 每爬一次，剩下的台阶数就会变化，且爬一阶，和爬两阶，剩下的台阶数不同，爬的方法数就会变化
> > 
> > 设`i`为要爬的总台阶数，则`dp[i]`表示爬到第`i`个台阶需要支付的费用的最小总和
> > 
> > 递归公式为`dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`: 要么第`i`层是我们到第`i-1`阶后一步`1`阶上来，要么是第`i-2`层后一步`2`阶上来
> > 
> > 初始化为：`dp[0] = 0; dp[1] = dp[0] + cost[0];` 分析一下对不对？
> >
> > 不对，因为有两种情况
> > * 从下标为`0`开始爬楼梯
> > * 从下标为`1`开始爬楼梯
> > </font>
> 
> </font>
>
> 
> <font color="gree">
>
> 动态规划的`5`步曲
> 
> 1. 确定`dp`数组（`dp table`）以及下标的含义: 即`dp[i]`代表什么？
> > 
> > `dp[i]`的定义为：爬到第`i`个台阶需要支付的费用的最小总和
> > 
> > ```c++
> > // 从下标为0开始爬楼梯
> > // 构建dp0数组
> > vector<int> dp0(n+1, 0);
> > 
> > // 从下标为1开始爬楼梯
> > // 构建dp1数组
> > vector<int> dp1(n+1, 0);
> > ```
> 
> 2. 确定递推公式（状态转移方程）
> > 
> > `dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`
> > 
> > 要么第`i`阶是我们到第`i-1`阶后一步`1`阶上来，要么是第`i-2`阶后一步`2`阶上来，计算清楚`dp[i-1]`和`dp[i-2]`爬上来的`cost总和`，求最小值
> > 
> 3. `dp`数组如何初始化
> > 
> > ```c++
> > // 从下标为0开始爬楼梯
> > // 构建dp0数组
> > vector<int> dp0(n+1, 0);
> > // 初始化
> > dp0[0] = 0;
> > dp0[1] = dp0[0] + cost[0]; 
> > 
> > // 从下标为1开始爬楼梯
> > // 构建dp1数组
> > vector<int> dp1(n+1, 0);        
> > // 初始化
> > dp1[1] = 0;
> > dp1[2] = dp1[1] + cost[1];
> > ```
> > 
> 4. 确定遍历顺序
> > 
> > 从递归公式`dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);`中可以看出，`dp[i]`是依赖 `dp[i - 1] 和 dp[i - 2]`，那么遍历的顺序一定是从前到后遍历的
> > 
> 5. 举例推导`dp`数组（举例是为了搞清楚状态转移）
> > 
> > 略
> > 
> 
> ```c++
> class Solution {
> public:
>     int minCostClimbingStairs(vector<int>& cost) {
>         // 这里很明显：一个状态可以由上一个状态推到，用动态规划
>         
>         // 已知cost[0]、cost[1]、cost[2]、...、cost[n-1]
>         int n = cost.size();
> 
>         // 构建dp数组
>         // dp[i]的含义：爬到第i个台阶需要支付的费用的最小总和sum = sigma(cost[])
> 
>         // 递推公式
>         // dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
>         // 要么由第i-1级台阶，向上爬一个台阶
>         // 要么第i-2级台阶，向上爬两个台阶
>         
> 
>         // 从下标为0开始爬楼梯
>         // 构建dp0数组
>         vector<int> dp0(n+1, 0);
>         // 初始化
>         dp0[0] = 0;
>         dp0[1] = dp0[0] + cost[0]; 
>         // 遍历
>         for(int i=2; i <= n; i++) {
>             dp0[i] = min(dp0[i-1] + cost[i-1], dp0[i-2] + cost[i-2]);
>         }
> 
>         // 从下标为1开始爬楼梯
>         // 构建dp1数组
>         vector<int> dp1(n+1, 0);        
>         // 初始化
>         dp1[1] = 0;
>         dp1[2] = dp1[1] + cost[1];
>         // 遍历
>         for(int i=3; i <= n; i++) {
>             dp1[i] = min(dp1[i-1] + cost[i-1], dp1[i-2] + cost[i-2]);
>         }
> 
>         // 返回
>         return min(dp0[n], dp1[n]);
>     }
> };
> ```
> 
> 


>
> **<font color="yellow">优化</font>**
>
> <font color="gree">我们从递推公式可以看出</font>
>
> ```c++
> dp[i] = min(dp0[i], dp1[i]) 
> // 代入递推公式
> = min(min(dp0[i-1] + cost[i-1], dp0[i-2] + cost[i-2]), min(dp1[i-1] + cost[i-1], dp1[i-2] + cost[i-2])) 
> // 本质上是四个值比较
> = min(dp0[i-1] + cost[i-1], dp0[i-2] + cost[i-2], dp1[i-1] + cost[i-1], dp1[i-2] + cost[i-2]) 
> // 移动位置
> = min(dp0[i-1] + cost[i-1], dp1[i-1] + cost[i-1], dp0[i-2] + cost[i-2], dp1[i-2] + cost[i-2]) 
> // 加入括号
> = min(min(dp0[i-1] + cost[i-1], dp1[i-1] + cost[i-1]), min(dp0[i-2] + cost[i-2], dp1[i-2] + cost[i-2]) )
> // 提取cost[i-1]和cost[i-2]
> = min( min(dp0[i-1], dp1[i-1]) + cost[i-1], min(dp0[i-2], dp1[i-2]) + cost[i-2] )
> // 由于dp[i-1] = min(dp0[i-1], dp1[i-1]) 
> // 由于dp[i-2] = min(dp0[i-2], dp1[i-2]) 
> // 则有
> = min(dp[i-1] + cost[i-1], cost[i-2] + cost[i-2])
> ```
>
> 即使我们分成了`dp0[]`和`dp1[]`，递推公式的本质依然是`dp[i] = min(dp[i-1] + cost[i-1], cost[i-2] + cost[i-2])`
>
> 我们只需要计算出`dp[0]、dp[1]`，然后递推就行了
> 
> <font color="gree">我们详细看一下</font>
>
> ```c++
> // 从下标为0开始爬楼梯
> dp0[0] = 0; // dp0[0]=0
> dp0[1] = dp0[0] + cost[0];  // dp0[1]=cost[0]
> dp0[2] = min(dp0[0] + cost[0], dp0[1] + cost[1]); //dp0[2]=min(cost[0], cost[1])
> 
> // 从下标为1开始爬楼梯
> dp1[1] = 0;         // dp0[1]=0
> dp1[2] = dp1[1] + cost[1];  // dp0[2] = cost[1]
> ```
>
> 由于我们最后`return min(dp0[n], dp1[n]);`, 所以实际上
> 
> ```c++
> // 综上
> dp[0] = 0; // dp[0] = 0
> dp[1] = min(dp0[1],dp1[1]); // dp[1] = 0
> dp[2] = min(dp0[2],dp1[2]); // dp[2] = min(cost[0], cost[1]) = min(dp[2-1] + cost[2-1], dp[2-2] + cost[2-2])
> ```  
> 有`dp[2] = min(dp[2-1] + cost[2-1], dp[2-2] + cost[2-2]) = min(cost[0], cost[1])`
> 
> 完全不用使用`dp0[]`和`dp1[]`两个数组
>
> <font color="gree">我们只需要设置`dp[0] = 0; dp[1] = 0;`然后就可以从`i=2`开始递推了</font>
>
> 代码如下：
> 
> ```c++
> class Solution {
> public:
>     int minCostClimbingStairs(vector<int>& cost) {
>         // 这里很明显：一个状态可以由上一个状态推到，用动态规划
>         
>         // 已知cost[0]、cost[1]、cost[2]、...、cost[n-1]
>         int n = cost.size();
> 
>         // 构建dp数组
>         vector<int> dp(n+1, 0);
>         // dp[i]的含义：爬到第i个台阶需要支付的费用的最小总和sum = sigma(cost[])
> 
>         // 递推公式
>         // dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
>         // 要么由第i-1级台阶，向上爬一个台阶
>         // 要么第i-2级台阶，向上爬两个台阶
>         
>         // 初始化
>         dp[0] = 0;
>         dp[1] = 0; 
>         
>         // 遍历
>         for(int i=2; i <= n; i++) {
>             dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
>         }
> 
>         // 返回
>         return dp[n];
>     }
> };
> ```
> 
> 
> 


#### 代码随想录

>
> 题目中说 “你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯” 也就是相当于 跳到 下标 `0` 或者 下标 `1` 是不花费体力的， 从 下标 `0` 下标`1` 开始跳就要花费体力了。
>
> 1. 确定`dp`数组以及下标的含义
>
> 使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组`dp[i]`就可以了。
>
> `dp[i]的`定义：到达第`i`台阶所花费的最少体力为`dp[i]`。
>
> **对于`dp`数组的定义，大家一定要清晰！**
>
> 
> 2. 确定递推公式
>
> 可以有两个途径得到`dp[i]`，一个是`dp[i-1] `一个是`dp[i-2]`。
>
> `dp[i - 1]` 跳到 `dp[i]` 需要花费 `dp[i - 1] + cost[i - 1]`。
> 
> dp`[i - 2]` 跳到 `dp[i]` 需要花费 `dp[i - 2] + cost[i - 2]`。
>
> 那么究竟是选从`dp[i - 1]`跳还是从`dp[i - 2]`跳呢？
>
> 一定是选最小的，所以`dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);`
>
> 3. `dp`数组如何初始化
>
> 看一下递归公式，`dp[i]`由`dp[i - 1]`，`dp[i - 2]`推出，既然初始化所有的`dp[i]`是不可能的，那么只初始化`dp[0]`和`dp[1]`就够了，其他的最终都是`dp[0]dp[1]`推出。
>
> 那么 `dp[0]` 应该是多少呢？ 根据dp数组的定义，到达第`0`台阶所花费的最小体力为`dp[0]`，那么有同学可能想，那`dp[0]` 应该是 `cost[0]`，例如` cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]` 的话，`dp[0]` 就是` cost[0]` 应该是`1`。
> 
> 题目描述中明确说了 “你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。” 也就是说 到达 第 `0` 个台阶是不花费的，但从 第`0` 个台阶 往上跳的话，需要花费 `cost[0]`。
> 
> 所以初始化 `dp[0] = 0，dp[1] = 0;`
>
> 
> 4. 确定遍历顺序
>
> 最后一步，递归公式有了，初始化有了，如何遍历呢？
>
> 本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。
>
> 因为是模拟台阶，而且`dp[i]`由`dp[i-1]dp[i-2]`推出，所以是从前到后遍历`cost`数组就可以了。
>
> > <font color="gree">
> > 
> > 但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来。 例如：`01背包`，都知道两个`for`循环，一个`for`遍历物品嵌套一个`for`遍历背包容量，那么为什么不是一个`for`遍历背包容量嵌套一个`for`遍历物品呢？ 以及在使用一维`dp`数组的时候遍历背包容量为什么要倒序呢？
> > 
> > </font>
>
> 
> 5. 举例推导`dp`数组
>
> 拿示例`2`：`cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]` ，来模拟一下`dp`数组的状态变化，如下：
>
> 
> <div align=center>
> <img src="./images/min_cost_climbing_stairs_1.png" style="zoom:100%;"/>
> </div>
> 
> 如果大家代码写出来有问题，就把`dp`数组打印出来，看看和如上推导的是不是一样的。
>
> 以上分析完毕，整体C++代码如下：
> 
> ```c++
> // 版本一
> class Solution {
> public:
>     int minCostClimbingStairs(vector<int>& cost) {
>         vector<int> dp(cost.size() + 1);
>         dp[0] = 0; // 默认第一步都是不花费体力的
>         dp[1] = 0;
>         for (int i = 2; i <= cost.size(); i++) {
>             dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
>         }
>         return dp[cost.size()];
>     }
> };
> ```
>
> * 时间复杂度：`O(n)`
> * 空间复杂度：`O(n)`
> 
> 还可以优化空间复杂度，因为`dp[i]`就是由前两位推出来的，那么也不用`dp`数组了，`C++`代码如下：
>
> ```c++
> // 版本二
> class Solution {
> public:
>     int minCostClimbingStairs(vector<int>& cost) {
>         int dp0 = 0;
>         int dp1 = 0;
>         for (int i = 2; i <= cost.size(); i++) {
>             int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);
>             dp0 = dp1; // 记录一下前两位
>             dp1 = dpi;
>         }
>         return dp1;
>     }
> };
> ```
>
> * 时间复杂度：`O(n)`
> * 空间复杂度：`O(1)`
>
> 
> <font color="gree">当然如果在面试中，能写出版本一就行，除非面试官额外要求 空间复杂度，那么再去思考版本二，因为版本二还是有点绕。版本一才是正常思路</font>
>
> 
> 


##### 拓展

>
> 旧力扣描述，如果按照 第一步是花费的，最后一步不花费，那么代码是这么写的，提交也可以通过
>
> ```c++
> // 版本一
> class Solution {
> public:
>     int minCostClimbingStairs(vector<int>& cost) {
>         vector<int> dp(cost.size());
>         dp[0] = cost[0]; // 第一步有花费
>         dp[1] = cost[1];
>         for (int i = 2; i < cost.size(); i++) {
>             dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
>         }
>         // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值
>         return min(dp[cost.size() - 1], dp[cost.size() - 2]);
>     }
> };
> ```
> 
> 当然如果对 动态规划 理解不够深入的话，拓展内容就别看了，容易越看越懵。
> 


##### 总结

>
> 大家可以发现这道题目相对于 昨天的动态规划：爬楼梯 (`_2_climbing_stairs.md`)又难了一点，但整体思路是一样的。
>
> 从动态规划：斐波那契数 (`_1_fibonacci_number.md`)到 动态规划：爬楼梯 (`_2_climbing_stairs.md`)再到今天这道题目，录友们感受到循序渐进的梯度了嘛。
>
> 每个系列开始的时候，都有录友和我反馈说题目太简单了，赶紧上难度，但也有录友和我说有点难了，快跟不上了。
>
> 其实我选的题目都是有目的性的，就算是简单题，也是为了练习方法论，然后难度都是梯度上来的，一环扣一环。
>
> 但我也可以随便选来一道难题讲呗，这其实是最省事的，不用管什么题目顺序，看心情找一道就讲。
>
> 难的是把题目按梯度排好，循序渐进，再按照统一方法论把这些都串起来，所以大家不要催我哈，按照我的节奏一步一步来就行了。
>
> 


















