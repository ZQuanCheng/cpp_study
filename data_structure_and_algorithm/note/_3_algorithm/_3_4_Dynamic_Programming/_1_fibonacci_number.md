# cpp_algorithms

* 代码随想录 https://programmercarl.com/

* geeksforgeeks https://www.geeksforgeeks.org

--------------------------------------------------------------------------------
> **大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。**
> 
> 做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，
> 
> 一样的代码多提交几次可能就击败百分之百了....
--------------------------------------------------------------------------------

# 动态规划

https://www.geeksforgeeks.org/dynamic-programming/

--------------------------------------------------------------------------------

## 斐波那契数

## _1_fibonacci_number.md

--------------------------------------------------------------------------------

### 509. 斐波那契数

> 
> Leetcode链接: https://leetcode.cn/problems/fibonacci-number/
>
> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> > `F(0) = 0，F(1) = 1`
> > `F(n) = F(n - 1) + F(n - 2)，其中 n > 1`
>
> 给定 `n` ，请计算 `F(n)` 。
>
> 
> **示例1：**
> 
> ```html
> 输入：n = 2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
> ```
> 
> **示例2：**
> 
> ```html
> 输入：n = 3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
> ```
> 
> **示例3：**
> 
> ```html
> 输入：n = 4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3
> ```
>
> **提示：**
> * `0 <= n <= 30`
>
> ```c++
> class Solution {
> public:
>     int fib(int n) {
> 
>     }
> };
> ```
> 



#### 我的代码

##### 递归法

>
> **其实这个题目，第一个想法就是递归实现**
>
> ```c++
> class Solution {
> private: 
>     // 确定递归函数的参数和返回值、停止条件、递归逻辑
>     int recursion(int i) {
>         // 当i = 0 或 1时，直接返回
>         if(i == 0) return 0;
>         if(i == 1) return 1;
>         // 递推公式
>         int temp = recursion(i-1) + recursion(i-2);
>         return temp;
>     }
> public:
>     int fib(int n) {
>         int result = recursion(n);
>         return result;
>     }
> };
> ```
>
> **再简化一下**
>
> ```c++
> class Solution {
> private:
>     // 确定递归函数的参数和返回值、停止条件、递归逻辑
>     int recursion(int i) {
>         // 当i = 0 或 1时，直接返回
>         if(i == 0) return 0;
>         if(i == 1) return 1;
>         // 递推公式
>         return recursion(i-1) + recursion(i-2);
>     }    
>     
> public: 
>     int fib(int n) {
>         int result = recursion(n);
>         return result;
>     }
> };
> ```
>
> 

##### 动态规划

> 
> **<font color="yellow">如何就成了动态规划的例题了呢？</font>**
> 
> <font color="gree">
>
> 怎么实现动态规划的`5`步？
> 
> 1. 确定`dp`数组（`dp table`）以及下标的含义: 即`dp[i]`代表什么？
> > 
> > `dp[i]`的定义为：第`i`个数的斐波那契数值是`dp[i]`
> > 
> 2. 确定递推公式（状态转移方程）
> > 
> > 为什么这是一道非常简单的入门题目呢？
> > 
> > 因为题目已经把递推公式直接给我们了：状态转移方程 `dp[i] = dp[i - 1] + dp[i - 2];`
> > 
> 3. `dp`数组如何初始化
> > 
> > **题目中把如何初始化也直接给我们了，如下：**
> > ```c++
> > dp[0] = 0;
> > dp[1] = 1;
> > ```
> > 
> 4. 确定遍历顺序
> > 
> > 从递归公式`dp[i] = dp[i - 1] + dp[i - 2];`中可以看出，`dp[i]`是依赖 `dp[i - 1] 和 dp[i - 2]`，那么遍历的顺序一定是从前到后遍历的
> > 
> 5. 举例推导`dp`数组（举例是为了搞清楚状态转移）
> > 
> > 按照这个递推公式`dp[i] = dp[i - 1] + dp[i - 2]`，我们来推导一下，当`N`为`10`的时候，`dp`数组应该是如下的数列：
> > 
> > `0 1 1 2 3 5 8 13 21 34 55`
> > 
> </font>
> 
> 如果代码写出来，发现结果不对，就把`dp`数组打印出来看看和我们推导的数列是不是一致的。
>
> **代码如下：**
> 
> ```c++
> class Solution {
> public:
>     int fib(int n) {
>         // 必须考虑到n=0的情况，不然后面初始化时会报错
>         // 既然都考虑到n=0了，那么就一并处理n=1
>         if (n <= 1) return n; // if (n <= 0) return n; 也可以
> 
>         // 构建dp[i]数组，确定其含义: 第i个数的斐波那契数值是dp[i]
>         vector<int> dp(n+1); // 因为i从0开始，所以dp数组长度为n+1
>         // 确定递推公式：dp[i] = dp[i-1] + dp[i-2];
>         // dp数组初始化
>         dp[0] = 0;
>         dp[1] = 1;
>         // 遍历，得到dp数组的所有元素值dp[i]
>         for(int i=2; i <= n; i++) {
>             dp[i] = dp[i-1] + dp[i-2];
>         }
>         // 返回dp[n]
>         return dp[n];
>     }
> };
> ```
> 
> * 时间复杂度：`O(n)`
> * 空间复杂度：`O(n)`
> 
>
> 优化空间复杂度，代码如下：
>
> 我们只需要维护两个数值就可以了，不需要记录整个序列。
> 
> ```c++
> class Solution {
> public:
>     int fib(int n) {
>         // 必须考虑到n=0的情况，不然后面初始化时会报错
>         // 既然都考虑到n=0了，那么就一并处理n=1
>         if (n <= 1) return n; // if (n <= 0) return n; 也可以
> 
>         vector<int> dp(2); 
>         dp[0] = 0;
>         dp[1] = 1;
>         // 遍历，得到dp数组的所有元素值dp[i]
>         for(int i=2; i <= n; i++) {
>             int sum = dp[0] + dp[1];
>             dp[0] = dp[1];
>             dp[1] = sum;
>         }
>         // 返回dp[1]
>         return dp[1];
>     }
> };
> ```
> 
> * 时间复杂度：`O(n)`
> * 空间复杂度：`O(1)`
> 








#### 代码是随想录

##### 思路

>
> 斐波那契数列大家应该非常熟悉不过了，非常适合作为动规第一道题目来练练手。
> 
> 因为这道题目比较简单，可能一些同学并不需要做什么分析，直接顺手一写就过了。
> 
> 但 **「代码随想录」的风格是：简单题目是用来加深对解题方法论的理解的。**
>
> 通过这道题目让大家可以初步认识到，按照动规五部曲是如何解题的。
>
> 对于动规，如果没有方法论的话，可能简单题目可以顺手一写就过，难一点就不知道如何下手了。
>
> 所以我总结的<font color="gree">动规五部曲</font>，是要用来贯穿整个动态规划系列的，就像之前讲过二叉树系列的<font color="gree">递归三部曲</font> (`../../_2_data_structure/_2_6_Binary_Tree/Binary_Tree.md`)，回溯法系列的<font color="gree">回溯三部曲</font> (`../../_3_algorithm/_3_1_Sorting_Algorithms/backtracking_algorithms.md`)一样。后面慢慢大家就会体会到，**动规五部曲方法的重要性**
>
> 

##### 动态规划

>
> 动规五部曲：
>
> 这里我们要用一个一维`dp`数组来保存递归的结果
>
> 1. 确定`dp`数组以及下标的含义: 即`dp[i]`代表什么？
> > 
> > `dp[i]`的定义为：第`i`个数的斐波那契数值是`dp[i]`
> > 
> 2. 确定递推公式（状态转移公式）
> > 
> > 为什么这是一道非常简单的入门题目呢？
> > 
> > 因为题目已经把递推公式直接给我们了：状态转移方程 `dp[i] = dp[i - 1] + dp[i - 2];`
> > 
> 3. `dp`数组如何初始化
> > 
> > **题目中把如何初始化也直接给我们了，如下：**
> > ```c++
> > dp[0] = 0;
> > dp[1] = 1;
> > ```
> > 
> 4. 确定遍历顺序
> > 
> > 从递归公式`dp[i] = dp[i - 1] + dp[i - 2];`中可以看出，`dp[i]`是依赖 `dp[i - 1] 和 dp[i - 2]`，那么遍历的顺序一定是从前到后遍历的
> > 
> 5. 举例推导`dp`数组（举例是为了搞清楚状态转移）
> > 
> > 按照这个递推公式`dp[i] = dp[i - 1] + dp[i - 2]`，我们来推导一下，当`N`为`10`的时候，`dp`数组应该是如下的数列：
> > 
> > `0 1 1 2 3 5 8 13 21 34 55`
> > 
> 
> 
> 如果代码写出来，发现结果不对，就把`dp`数组打印出来看看和我们推导的数列是不是一致的。
>
> 以上我们用动规的方法分析完了，`C++`代码如下：
>
> ```c++
> class Solution {
> public:
>     int fib(int N) {
>         if (N <= 1) return N;
>         vector<int> dp(N + 1);
>         dp[0] = 0;
>         dp[1] = 1;
>         for (int i = 2; i <= N; i++) {
>             dp[i] = dp[i - 1] + dp[i - 2];
>         }
>         return dp[N];
>     }
> };
> ```
> 
> * 时间复杂度：`O(n)`
> * 空间复杂度：`O(n)`
> 
> 我们只需要维护两个数值就可以了，不需要记录整个序列。
> 
> 代码如下：
> 
> ```c++
> class Solution {
> public:
>     int fib(int N) {
>         if (N <= 1) return N;
>         int dp[2];
>         dp[0] = 0;
>         dp[1] = 1;
>         for (int i = 2; i <= N; i++) {
>             int sum = dp[0] + dp[1];
>             dp[0] = dp[1];
>             dp[1] = sum;
>         }
>         return dp[1];
>     }
> };
> ```
> 
> * 时间复杂度：`O(n)`
> * 空间复杂度：`O(1)`
> 
> 




##### 递归解法


>
> 本题还可以使用递归解法来做
>
> 代码如下：
>
> ```c++
> class Solution {
> public:
>     int fib(int N) {
>         if (N < 2) return N;
>         return fib(N - 1) + fib(N - 2);
>     }
> };
> ```
>
> * 时间复杂度：`O(2^n)`
> * 空间复杂度：`O(n)`，算上了编程语言中实现递归的系统栈所占空间
>
> 这个递归的时间复杂度大家画一下树形图就知道了，如果不清晰的同学，可以看这篇：[通过一道面试题目，讲一讲递归算法的时间复杂度！](https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html)
>
> 
> 


##### 总结

>
> 斐波那契数列这道题目是非常基础的题目，我在后面的动态规划的讲解中将会多次提到斐波那契数列！
> 
> 这里我严格按照关于动态规划，你该了解这些！ (`dynamic_programming.md`)中的动规五部曲来分析了这道题目，一些分析步骤可能同学感觉没有必要搞的这么复杂，代码其实上来就可以撸出来。
> 
> 但我还是强调一下，**简单题是用来掌握方法论的，动规五部曲将在接下来的动态规划讲解中发挥重要作用，敬请期待！**
>
> 就酱，循序渐进学算法，认准「代码随想录」！
> 



















