# cpp_algorithms

* 代码随想录 https://programmercarl.com/

* geeksforgeeks https://www.geeksforgeeks.org

--------------------------------------------------------------------------------
> **大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。**
> 
> 做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，
> 
> 一样的代码多提交几次可能就击败百分之百了....
--------------------------------------------------------------------------------

# 动态规划

https://www.geeksforgeeks.org/dynamic-programming/

--------------------------------------------------------------------------------

## 爬楼梯

## _2_climbing_stairs.md

--------------------------------------------------------------------------------

### 70. 爬楼梯

> 
> Leetcode链接: https://leetcode.cn/problems/climbing-stairs/
>
> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> 
> **示例1：**
> 
> ```html
> 输入：n = 2
> 输出：2
> 解释：有两种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶
> 2. 2 阶
> ```
> 
> **示例2：**
> 
> ```html
> 输入：n = 3
> 输出：3
> 解释：有三种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶
> ```
>
> **提示：**
> * `1 <= n <= 45`
>
> ```c++
> class Solution {
> public:
>     int climbStairs(int n) {
> 
>     }
> };
> ```
> 
> 




#### 我的思路及代码

> <font color="yellow">
> 
> 为什么想到要用动态规划？？？
>
> * 该问题有很多重叠子问题
> > <font color="yellow">
> > 
> > 如果只是这个原因，那么也许可以用贪心算法，局部选最优，但是还有一个原因
> > 
> > </font>
>
> * 每一个状态一定是由上一个状态推导出来的
> > <font color="yellow">
> > 
> > 每爬一次，剩下的台阶数就会变化，且爬一阶，和爬两阶，剩下的台阶数不同，爬的方法数就会变化
> > 
> > 我们反过来看，设`i`为要爬的总台阶数，则`dp[i]`表示一共有`dp[i]`种方法可以爬到第`i`阶
> > 
> > 递归公式为`dp[i] = dp[i-1] + dp[i-2]`: 要么第`i`层是我们到第`i-1`阶后一步`1`阶上来，要么是第`i-2`层后一步`2`阶上来
> > 
> > 初始化为：`dp[1] = 1; dp[2] = 2; dp[3] = 3; dp[4] = 5;` 分析一下对不对？
> > 
> > </font>
> 
> </font>
>
> 
> <font color="gree">
>
> 动态规划的`5`步曲
> 
> 1. 确定`dp`数组（`dp table`）以及下标的含义: 即`dp[i]`代表什么？
> > 
> > `dp[i]`的定义为：有`dp[i]`种方法可以爬到第`i`阶
> > 
> 2. 确定递推公式（状态转移方程）
> > 
> > `dp[i] = dp[i-1] + dp[i-2]`
> > 
> > 要么第`i`阶是我们到第`i-1`阶后一步`1`阶上来，要么是第`i-2`阶后一步`2`阶上来，计算清楚`dp[i-1]`和`dp[i-2]`爬楼梯的方法数，加起来就行
> > 
> 3. `dp`数组如何初始化
> > 
> > ```c++
> > dp[1] = 1; 
> > dp[2] = 2;
> > ```
> > 有两种方法可以爬到2阶。
> > 1. `1` 阶 + `1` 阶
> > 2. `2` 阶
> > 
> 4. 确定遍历顺序
> > 
> > 从递归公式`dp[i] = dp[i - 1] + dp[i - 2];`中可以看出，`dp[i]`是依赖 `dp[i - 1] 和 dp[i - 2]`，那么遍历的顺序一定是从前到后遍历的
> > 
> 5. 举例推导`dp`数组（举例是为了搞清楚状态转移）
> > 
> > 按照这个递推公式`dp[i] = dp[i - 1] + dp[i - 2]`，
> > 我们来推导一下
> > 
> > 有三种方法可以爬到`3`阶。`dp[3] = dp[2] + dp[1] = 2 + 1 = 3`
> > 1. `1` 阶 + `1` 阶 + `1` 阶
> > 2. `1` 阶 + `2` 阶
> > 3. `2` 阶 + `1` 阶
> > 
> > 有五种方法可以爬到`4`阶。`dp[4] = dp[3] + dp[2] = 3 + 2 = 5`
> > 1. `1` 阶 + `1` 阶 + `1` 阶 + `1` 阶
> > 2. `1` 阶 + `1` 阶 + `2` 阶
> > 3. `1` 阶 + `2` 阶 + `1` 阶
> > 4. `2` 阶 + `1` 阶 + `1` 阶
> > 5. `2` 阶 + `2` 阶
> >
> > 有五种方法可以爬到`5`阶。`dp[5] = dp[4] + dp[3] = 5 + 3 = 8`
> > 1. `1` 阶 + `1` 阶 + `1` 阶 + `1` 阶 + `1` 阶
> > 2. `1` 阶 + `1` 阶 + `1` 阶 + `2` 阶
> > 3. `1` 阶 + `1` 阶 + `2` 阶 + `1` 阶
> > 4. `1` 阶 + `2` 阶 + `1` 阶 + `1` 阶 
> > 5. `1` 阶 + `2` 阶 + `2` 阶
> > 6. `2` 阶 + `1` 阶 + `1` 阶 + `1` 阶 
> > 7. `2` 阶 + `1` 阶 + `2` 阶
> > 8. `2` 阶 + `2` 阶 + `1` 阶 
> > 
> 
> 
> </font>
> 
> 
> ```c++
> class Solution {
> public:
>     int climbStairs(int n) {
>         // 构建dp[i]数组，确定其含义: 有dp[i]种方法可以爬到第i阶
>         vector<int> dp(n+2);  // 如果长度初始化为n+1, 则报错，因为下面有一句dp[2] = 2; n=1时只分配两个内存不够
> 
>         // 确定递推公式：dp[i] = dp[i-1] + dp[i-2];
>         // 要么第i阶是我们到第i-1阶后一步1阶上来，要么是第i-2阶后一步2阶上来，
>         // 计算清楚dp[i-1]和dp[i-2]爬楼梯的方法数，加起来就行
> 
>         // dp数组初始化
>         dp[0] = 0;
>         dp[1] = 1;
>         dp[2] = 2;    
> 
>         // 递推
>         for(int i=3; i <= n; i++) {
>             dp[i] = dp[i-1] + dp[i-2];
>         }     
>         
>         // 返回dp[n]
>         return dp[n]; 
>     }
> };
> ```
> 
> 







#### 代码随想录

##### 思路

>
> 本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。
>
> 爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。
>
> 那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层
>
> 所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。
>
> 我们来分析一下，动规五部曲：
>
> 定义一个一维数组来记录不同楼层的状态
>
> 1. 确定`dp`数组以及下标的含义
> > 
> > `dp[i]`： 爬到第`i`层楼梯，有`dp[i]`种方法
> > 
> 
> 2. 确定递推公式
>
> > 如何可以推出`dp[i]`呢？
> > 
> > 从`dp[i]`的定义可以看出，`dp[i]` 可以有两个方向推出来。
> > 
> > 首先是`dp[i - 1]`，上`i-1`层楼梯，有`dp[i - 1]`种方法，那么再一步跳一个台阶不就是`dp[i]`了么。
> > 
> > 还有就是`dp[i - 2]`，上`i-2`层楼梯，有`dp[i - 2]`种方法，那么再一步跳两个台阶不就是`dp[i]`了么。
> >  
> > 那么`dp[i]`就是 `dp[i - 1]`与`dp[i - 2]`之和！
> > 
> > 所以`dp[i] = dp[i - 1] + dp[i - 2]` 。
> > 
> > 在推导`dp[i]`的时候，一定要时刻想着`dp[i]`的定义，否则容易跑偏。
> > 
> > 这体现出确定`dp`数组以及下标的含义的重要性！
> > 
>
> 3. `dp`数组如何初始化
> > 
> > 再回顾一下`dp[i]`的定义：爬到第`i`层楼梯，有`dp[i]`种方法。
> > 
> > 那么`i`为`0`，`dp[i]`应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。
> > 
> > 例如强行安慰自己爬到第`0`层，也有一种方法，什么都不做也就是一种方法即：`dp[0] = 1`，相当于直接站在楼顶。
> > 
> > **其实这么争论下去没有意义，大部分解释说`dp[0]`应该为`1`的理由其实是因为`dp[0]=1`的话在递推的过程中`i`从`2`开始遍历本题就能过，然后就往结果上靠去解释`dp[0] = 1`。**
> > 
> > 从`dp`数组定义的角度上来说，`dp[0] = 0` 也能说得通。
> > 
> > 需要注意的是：题目中说了`n`是一个正整数，题目根本就没说`n`有为`0`的情况。
> > 
> > 所以本题其实就不应该讨论`dp[0]`的初始化！
> > 
> > 我相信`dp[1] = 1，dp[2] = 2`，这个初始化大家应该都没有争议的。
> > 
> > 所以我的原则是：不考虑`dp[0]`如何初始化，只初始化`dp[1] = 1，dp[2] = 2`，然后从`i = 3`开始递推，这样才符合`dp[i]`的定义。
> > 
>
> 4. 确定遍历顺序
> > 
> > 从递推公式`dp[i] = dp[i - 1] + dp[i - 2];`中可以看出，遍历顺序一定是从前向后遍历的
> > 
>
> 5. 举例推导`dp`数组
> > 
> > 举例当`n`为`5`的时候，`dp table`（`dp`数组）应该是这样的
> >
> > 
> > <div align=center>
> > <img src="./images/climbing_stairs_1.png" style="zoom:100%;"/>
> > </div>
> > 
> > 如果代码出问题了，就把`dp table` 打印出来，看看究竟是不是和自己推导的一样。
> > 
> 
> **此时大家应该发现了，这不就是斐波那契数列么！**
> 
> 唯一的区别是，没有讨论`dp[0]`应该是什么，因为`dp[0]`在本题没有意义！
> 
> 
> 以上五部分析完之后，`C++`代码如下：
> 
> ```c++
> // 版本一
> class Solution {
> public:
>     int climbStairs(int n) {
>         if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
>         vector<int> dp(n + 1);
>         dp[1] = 1;
>         dp[2] = 2;
>         for (int i = 3; i <= n; i++) { // 注意i是从3开始的
>             dp[i] = dp[i - 1] + dp[i - 2];
>         }
>         return dp[n];
>     }
> };
> ```
> 
> * 时间复杂度：$O(n)$
> * 空间复杂度：$O(n)$
>
> 当然依然也可以，优化一下空间复杂度，代码如下：
> 
> ```c++
> // 版本二
> class Solution {
> public:
>     int climbStairs(int n) {
>         if (n <= 1) return n;
>         int dp[3];
>         dp[1] = 1;
>         dp[2] = 2;
>         for (int i = 3; i <= n; i++) {
>             int sum = dp[1] + dp[2];
>             dp[1] = dp[2];
>             dp[2] = sum;
>         }
>         return dp[2];
>     }
> };
> ```
> 
> * 时间复杂度：$O(n)$
> * 空间复杂度：$O(1)$
>
> 后面将讲解的很多动规的题目其实都是当前状态依赖前两个，或者前三个状态，都可以做空间上的优化，**但我个人认为面试中能写出版本一就够了哈，清晰明了，如果面试官要求进一步优化空间的话，我们再去优化。**
>
> <font color="gree">因为版本一才能体现出动规的思想精髓，递推的状态变化。</font>
>
> 
> 



##### 拓展

>
> 这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 `m` 个台阶，有多少种方法爬到 `n` 阶楼顶。
>
> 这又有难度了，这其实是一个完全背包问题，但力扣上没有这种题目，所以后续我在讲解背包问题的时候，今天这道题还会从背包问题的角度上来再讲一遍。 如果想提前看一下，可以看这篇:[70.爬楼梯完全背包版本](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)
>
> 这里我先给出我的实现代码：
>
> ```c++
> class Solution {
> public:
>     int climbStairs(int n) {
>         vector<int> dp(n + 1, 0);
>         dp[0] = 1;
>         for (int i = 1; i <= n; i++) {
>             for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题
>                 if (i - j >= 0) dp[i] += dp[i - j];
>             }
>         }
>         return dp[n];
>     }
> };
> ```
> 
> 代码中`m`表示最多可以爬`m`个台阶。
> 
> 以上代码不能运行哈，我主要是为了体现只要把`m`换成`2`，粘过去，就可以`AC`爬楼梯这道题，不信你就粘一下试试。
> 
> 此时我就发现一个绝佳的大厂面试题，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把`dp[0]`的定义成`1`了，就可以发难了，为什么`dp[0]`一定要初始化为`1`，此时可能候选人就要强行给`dp[0]`应该是`1`找各种理由。那这就是一个考察点了，对`dp[i]`的定义理解的不深入。
> 
> 然后可以继续发难，如果一步一个台阶，两个台阶，三个台阶，直到 `m`个台阶，有多少种方法爬到`n`阶楼顶。这道题目`leetcode`上并没有原题，绝对是考察候选人算法能力的绝佳好题。
> 
> 这一连套问下来，候选人算法能力如何，面试官心里就有数了。
> 
> **其实大厂面试最喜欢的问题就是这种简单题，然后慢慢变化，在小细节上考察候选人。**
>
> 


##### 总结

>
> 这道题目和动态规划：斐波那契数 (`_1_fibonacci_number.md`)题目基本是一样的，但是会发现本题相比动态规划：斐波那契数 (`_1_fibonacci_number.md`)难多了，为什么呢？
>
> 关键是 动态规划：斐波那契数 (`_1_fibonacci_number.md`)题目描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。
>
> 而本题，就需要逐个分析了，大家现在应该初步感受出关于动态规划，你该了解这些！ (`dynamic_programming.md`)里给出的动规五部曲了。
>
> 简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！
>
> 所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！
>
> 就酱，循序渐进学算法，认准「代码随想录」！
> 





#### 关于拓展，我的解答

>
> 问题：
> > 
> > 一步可以一个台阶，可以两个台阶，可以三个台阶，可以 `m` 个台阶，有多少种方法爬到 `n` 阶楼顶。（`m < n`）
> > 
> 
> 还是动态规划
> 
> <font color="gree">
>
> 动态规划的`5`步曲
> 
> 1. 确定`dp`数组（`dp table`）以及下标的含义: 即`dp[i]`代表什么？
> > 
> > `dp[i]`的定义为：有`dp[i]`种方法可以爬到第`i`阶
> > 
> 2. 确定递推公式（状态转移方程）
> > 
> > 要么第`i`阶是我们到第`i-1`阶后一步`1`阶上来，要么是第`i-2`阶后一步`2`阶上来, 要么是第`i-m`阶后一步`m`阶上来。但是`i`可能小于`m`，所以必须分类讨论
> >  
> > 当`2 < i <= m`时, `dp[i] = 1 + dp[i-1] + dp[i-2] + ... + dp[1], 2 < i <= m`
> > > 即只要不大于`m`，就可以一步到位，所以需要`1`, 然后才是`+ dp[i-1]`, 然后是`+ dp[i-2]`, ..., `+ dp[1]`
> > > 
> > 
> > 当`i > m`时, `dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m], i > m`
> > > 大于`m`时，无法一步到位`0`，然后是`+ dp[i-1]`, 然后是`+ dp[i-2]`, ..., `+ dp[i-m]`
> > > 
> 
> > 
> 3. `dp`数组如何初始化
> > 
> > ```c++
> > dp[1] = 1; 
> > dp[2] = 2;
> > ```
> > 
> 4. 确定遍历顺序
> > 
> > 从递归公式`dp[i] = dp[i - 1] + dp[i - 2] + ...;`中可以看出，`dp[i]`是依赖 `dp[i - 1]、dp[i - 2]、...`的，那么遍历的顺序一定是从前到后遍历的
> > 
> 5. 举例推导`dp`数组（举例是为了搞清楚状态转移）
> > 
> > 以`m = 4， n = 10`为例
> > 我们来推导一下
> > 
> > 有四种方法可以爬到`3`阶。`dp[3] = 1 + dp[2] + dp[1] = 1 + 2 + 1 = 4`
> > 1. `1` 阶 + `1` 阶 + `1` 阶
> > 2. `1` 阶 + `2` 阶
> > 3. `2` 阶 + `1` 阶
> > 4. `3` 阶
> > 
> > 有八种方法可以爬到`4`阶。`dp[4] = 1 + dp[3] + dp[2] + dp[1] = 1 + 4 + 2 + 1 = 8`
> > 1. `1` 阶 + `1` 阶 + `1` 阶 + `1` 阶
> > 2. `1` 阶 + `1` 阶 + `2` 阶
> > 3. `1` 阶 + `2` 阶 + `1` 阶
> > 4. `1` 阶 + `3` 阶
> > 5. `2` 阶 + `1` 阶 + `1` 阶
> > 6. `2` 阶 + `2` 阶
> > 7. `3` 阶 + `1` 阶 
> > 8. `4` 阶
> > 
> > 
> >
> > 有十五种方法可以爬到`5`阶。`dp[5] = dp[4] + dp[3] + dp[2] + dp[1] = 8 + 4 + 2 + 1 = 15`
> > 1. `1` 阶 + `1` 阶 + `1` 阶 + `1` 阶 + `1` 阶
> > 2. `1` 阶 + `1` 阶 + `1` 阶 + `2` 阶
> > 3. `1` 阶 + `1` 阶 + `2` 阶 + `1` 阶
> > 4. `1` 阶 + `1` 阶 + `3` 阶
> > 5. `1` 阶 + `2` 阶 + `1` 阶 + `1` 阶 
> > 6. `1` 阶 + `2` 阶 + `2` 阶
> > 7. `1` 阶 + `3` 阶 + `1` 阶
> > 8. `1` 阶 + `4` 阶
> > 9. `2` 阶 + `1` 阶 + `1` 阶 + `1` 阶 
> > 10. `2` 阶 + `1` 阶 + `2` 阶
> > 11. `2` 阶 + `2` 阶 + `1` 阶 
> > 12. `2` 阶 + `3` 阶
> > 13. `3` 阶 + `1` 阶 + `1` 阶
> > 14. `3` 阶 + `2` 阶
> > 15. `4` 阶 + `1` 阶
> > 
> 
> </font>
>
> **我的代码如下：**
> 
> ```c++
> class Solution {
> public:
>     int climbStairs(int n, int m) {
>         // 构建dp数组
>         // 如果长度初始化为n+1, 则报错，因为后面有dp[2] = 2; n=1时只分配两个内存不够
>         vector<int> dp(n + 2, 0); // 全部初始化为0
> 
>         // 初始化
>         dp[1] = 1;
>         dp[2] = 2;
> 
>         // 递推
>         // 当2 < i <= m时, dp[i] = 1 + dp[i-1] + dp[i-2] + ... + dp[1]
>         for(int i = 3; i <= m; i++) {
>             // 先执行dp[i] = 1 +
>             dp[i] += 1; 
>             // 再执行+ dp[i-j]
>             for(int j = 1; j <= i-1; j++) {
>                 dp[i] += dp[i-j];
>             }
>         } 
> 
>         // 当i > m时, dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m]
>         for(int i = m + 1; i <= n; i++) {
>             for(int j = 1; j <= m; j++) {
>                 dp[i] += dp[i-j];
>             }
>         }
>         
>         return dp[n];
>     }
> };
> ```
>
> **实机运行我的代码，实机代码如下：**
>
> ```c++
> #include <iostream>
> #include <vector>
> using namespace std;
> 
> int main()
> {
>     int m =4, n = 10;
> 
>     // 构建dp数组
>     // 如果长度初始化为n+1, 则报错，因为后面有dp[2] = 2; n=1时只分配两个内存不够
>     vector<int> dp(n + 2, 0); // 全部初始化为0
> 
>     // 初始化
>     dp[1] = 1;
>     dp[2] = 2;
> 
>     // 递推
>     // 当2 < i <= m时, dp[i] = 1 + dp[i-1] + dp[i-2] + ... + dp[1]
>     for(int i = 3; i <= m; i++) {
>         // 先执行dp[i] = 1 +
>         dp[i] += 1; 
>         // 再执行+ dp[i-j]
>         for(int j = 1; j <= i-1; j++) {
>             dp[i] += dp[i-j];
>         }
>     } 
> 
>     // 当i > m时, dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m]
>     for(int i = m + 1; i <= n; i++) {
>         for(int j = 1; j <= m; j++) {
>             dp[i] += dp[i-j];
>         }
>     }
> 
>     // 显示dp数组
>     cout << "dp[" << n << "] = {";
>     for(int i=1; i <= n; i++) {
>         cout << dp[i] << ", ";
>     }
>     cout << "}" << endl;
> 
> 
>     cout << endl;
>     pause(); // system("pause"); 
> 
>     return 0;
> }
> ```
>
> **我的代码，运行结果如下：**
>
> ```c++
> dp[10] = {1, 2, 4, 8, 15, 29, 56, 108, 208, 401, }
> ```
> 

>
> **优化递推公式**
> 
> <font color="gree">原来的推理如下</font>
> 
> 
> 2. 确定递推公式（状态转移方程）
> > 
> > 要么第`i`阶是我们到第`i-1`阶后一步`1`阶上来，要么是第`i-2`阶后一步`2`阶上来, 要么是第`i-m`阶后一步`m`阶上来。但是`i`可能小于`m`，所以必须分类讨论
> >  
> > 当`2 < i <= m`时, `dp[i] = 1 + dp[i-1] + dp[i-2] + ... + dp[1], 2 < i <= m`
> > > 即只要不大于`m`，就可以一步到位，所以需要`1`, 然后才是`+ dp[i-1]`, 然后是`+ dp[i-2]`, ..., `+ dp[1]`
> > > 
> > 
> > 当`i > m`时, `dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m], i > m`
> > > 大于`m`时，无法一步到位`0`，然后是`+ dp[i-1]`, 然后是`+ dp[i-2]`, ..., `+ dp[i-m]`
> > > 
> 
> 
> 3. `dp`数组如何初始化
> > 
> > ```c++
> > dp[1] = 1; 
> > dp[2] = 2;
> > ```
> > 
>
> <font color="gree">优化后的推理如下</font>
>
> > 我们修改`dp[i] = 1 + dp[i-1] + dp[i-2] + ... + dp[1], 2 < i <= m`
> > 
> > 设`dp[0] = 1`
> > 
> > 则当`2 < i <= m`时, `dp[i] = dp[i-1] + dp[i-2] + ... + dp[1] + dp[0], 2 < i <= m`
> > 
> > 现在看出，`i = 1`和`i = 2`也满足这个公式
> > 
> > 所以有
> > 
> > 当`1 <= i <= m`时, `dp[i] = dp[i-1] + dp[i-2] + ... + dp[1] + dp[0], 1 <= i <= m` 
> > 
> > 
> 
> <font color="yellow">1. 优化递推公式（状态转移方程）</font>
> 
> > 
> > <font color="yellow">
> > 
> > 当`1 <= i <= m`时, `dp[i] = dp[i-1] + dp[i-2] + ... + dp[1] + dp[0], 1 <= i <= m` 
> > 
> > 当`i > m`时, `dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m], i > m`
> > 
> > </font>
> > 
> 
> <font color="yellow">2. 修改`dp`数组初始化</font>
> 
> > ```c++
> > dp[0] = 1; 
> > ``
>
> 
>
> **我的优化后的代码如下：**
> 
> ```c++
> class Solution {
> public:
>     int climbStairs(int n, int m) {
>         // 构建dp数组
>         vector<int> dp(n + 1, 0); // 长度初始化为n+1，全部初始化为0
> 
>         // 初始化
>         dp[0] = 1;
> 
>         // 递推
>         // 当1 <= i <= m 时, dp[i] = dp[i-1] + dp[i-2] + ... + dp[1] + dp[0], 1 <= i <= m
>         for(int i = 1; i <= m; i++) {
>             for(int j = 1; j <= i; j++) {
>                 dp[i] += dp[i-j];
>             }
>         } 
> 
>         // 当i > m时, dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m], i > m
>         for(int i = m + 1; i <= n; i++) {
>             for(int j = 1; j <= m; j++) {
>                 dp[i] += dp[i-j];
>             }
>         }
>         
>         return dp[n];
>     }
> };
> ```
>
> **可以看到，`1 <= i <= m`和`i > m`的代码结构完全相同，可以归在一起, 内循环体中加一个`if(i >= j)`就可以**
>
> **最终代码如下**
> 
> ```c++
> class Solution {
> public:
>     int climbStairs(int n, int m) {
>         // 构建dp数组
>         vector<int> dp(n + 1, 0); // 长度初始化为n+1，全部初始化为0
> 
>         // 初始化
>         dp[0] = 1;
> 
>         // 递推
>         // 当1 <= i <= m 时, dp[i] = dp[i-1] + dp[i-2] + ... + dp[1] + dp[0], 1 <= i <= m
>         // 当i > m时, dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m], i > m
>         for(int i = 1; i <= n; i++) {
>             for(int j = 1; j <= m; j++) {
>                 if(i >= j) dp[i] += dp[i-j];
>             }
>         } 
>         
>         return dp[n];
>     }
> };
> ```
>
> **这就得到了代码随想录给的代码**
>
> **实机运行代码，结果如下：**
>
> ```c++
> #include <iostream>
> #include <vector>
> using namespace std;
> 
> int main()
> {
>     int m =4, n = 10;
> 
>     // 构建dp数组
>     vector<int> dp(n + 1, 0); // 长度初始化为n+1，全部初始化为0
> 
>     // 初始化
>     dp[0] = 1;
> 
>     // 递推
>     // 当1 <= i <= m 时, dp[i] = dp[i-1] + dp[i-2] + ... + dp[1] + dp[0], 1 <= i <= m
>     // 当i > m时, dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m], i > m
>     for(int i = 1; i <= n; i++) {
>         for(int j = 1; j <= m; j++) {
>             if(i >= j) dp[i] += dp[i-j];
>         }
>     } 
> 
>     // 显示dp数组
>     cout << "dp[" << n << "] = {";
>     for(int i=1; i <= n; i++) {
>         cout << dp[i] << ", ";
>     }
>     cout << "}" << endl;
> 
> 
>     cout << endl;
>     pause(); // system("pause"); 
> 
>     return 0;
> }
> ```
>
> **我的代码，运行结果如下：**
>
> ```c++
> dp[10] = {1, 2, 4, 8, 15, 29, 56, 108, 208, 401, }
> ```
> 

























