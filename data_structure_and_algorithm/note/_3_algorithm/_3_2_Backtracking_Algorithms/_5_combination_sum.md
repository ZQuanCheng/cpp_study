# cpp_algorithms

* 代码随想录 https://programmercarl.com/

* geeksforgeeks https://www.geeksforgeeks.org

--------------------------------------------------------------------------------
> **大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。**
> 
> 做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，
> 
> 一样的代码多提交几次可能就击败百分之百了....
--------------------------------------------------------------------------------

# 回溯算法

https://www.geeksforgeeks.org/backtracking-algorithms/

--------------------------------------------------------------------------------

## 组合总和

## _5_combination_sum.md

--------------------------------------------------------------------------------

### 39. 组合总和

> 
> Leetcode链接: https://leetcode.cn/problems/combination-sum/
>
> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。
>
> 
> **示例1：**
> 
> ```html
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
> 7 也是一个候选， 7 = 7 。
> 仅有这两种组合。
> ```
> 
> **示例2：**
> 
> ```html
> 输入: candidates = [2,3,5], target = 8
> 输出: [[2,2,2,2],[2,3,3],[3,5]]
> ```
> 
> **示例3：**
> 
> ```html
> 输入: candidates = [2], target = 1
> 输出: []
> ```
>
> **提示：**
> * `1 <= candidates.length <= 30`
> * `2 <= candidates[i] <= 40`
> * `candidates` 的所有元素 **互不相同**
> * `1 <= target <= 40`
>
> ```c++
> class Solution {
> public:
>     vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
> 
>     }
> };
> ```
> 

















